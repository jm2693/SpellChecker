Jason Merchan, jm2693
Daniel Li, dal279

Program Requirements:
    - argv[1] will be a path to a dictionary txt file.
    - there will be at least 3 arguments passed to the program
        - ./spchk argv[1] argv[2] ...
    - argv[2] onwards will be either a directory or a txt file
    - all txt files must be parsed through checking every word within each file

    What Constitues a Word?
    - punctuation counts as all non-alphabetical characters
    - a word cannot begin with any of the following quotations or brackets: '' , "" , () , [], {}
    - a word cannot end with any of the following: non-alphabetical characters and special characters, such as 'Ã©'
    - if a word from the txt file contains any of these in the order above, it will be ignored
        - ex: ""[()]?b/ob..//  ==>  ?b/ob
        - ex: "bob's./"  ==> bob's
    - any punctuation in the middle of a word is valid and will be treated as a part of the word when searching through the dictionary

    - Hyphens
        - a hyphenated word is multiple words separated by hyphens
        - all components of the hyphenated word must be correct for the entire word to be correct
        - if any incomponent does not return a match, the entire word will be incorrect 

Design Choices:
    Data Structure:
        - We've decided to go with a sorted array.
        - It will read through the dictionary once and then use binary search to look for each word in the txt files.


Design Idea:
        - For Dictionary
            - Open Dictionary File
            - create a char** arr[num_of_words][len_of_largest_word] and load every word into this array 
            - because a "correct word" can be either the dictionary word, a Capitalized Dictionary Word, or a CAPS DICTIONARY WORD
                - we have created three dictionaries. this requires more space but it more time efficient than creating one dictionary 
                    for all cases. 

        - For .txt/Directories
            - use DIR to recursively search through directories 
            - check to see if the current file is a dir 
                - if yes repeat until txt file found
            - if no check to see if it is a txt file
                - if yes read through the file and compare to dict
            - if NULL end while loop

        - Comparing txt and Dictionary 
            - using ASCII values of 65-90 for capital letters and 97-122 for lowercase 
            - use binary search to look for ASCII value version of txt file words
                - if first char in txt word is b/w 97-122, must also search for ASCII value word with first char minus 32
                - also, for every char b/w 97-122, minus 32
                - the above two search for First Character Uppercase and CAPS respectively 
            - if no word is found print error with line and column 
                - keep track of line with '\n'
                - keep track of column with simple counter, reverts back to 1 everytime it encounters '\n'
